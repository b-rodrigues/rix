---
title: "Running R or shell code in Nix from R"
output: html_document
editor_options:
  chunk_output_type: console
---

Adhering to sound versioning practices is crucial for ensuring the reproducibility of software. Despite the expertise in software engineering, the ever-growing complexity and continuous development of new, potentially disruptive features present significant challenges in maintaining code functionality over time. This pertains not only to backward compatibility but also to future-proofing. When code handles critical production loads and relies on numerous external software libraries, it's likely that these dependencies will evolve. Infrastructure-as-code and other DevOps principles shine in addressing these challenges. However, they may appear less approachable and more labor-intensive for the average R developer. Imagine you want to change your R version and external R packages for your in-house R package or function pipeline, which have worked fine so far. It's hard understand what happens beforehand

Are you ready to test your custom R functions and system commands in a a different environment with isolated software builds. And you want R, potentially any other software available from Nixpkgs to be both pure at build and at runtime, without leaving the R console? Let's introduce `with_nix()`, which exactly does this . `with_nix()` will evaluate custom R code or shell commands with command line interfaces provided by Nixpkgs in a Nix environment, and thereby bring the read-eval-print-loop feeling.

Nix is the cake, but let's eat dessert first.

```{r cars}
```
