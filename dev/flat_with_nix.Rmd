---
title: "with_nix"
output: html_document
editor_options:
  chunk_output_type: console
---

This function can evaluate an shell or R expression in Nix via `nix-shell` 
environment.

```{r, function-with-nix}

#' Evaluate function in R or shell command via `nix-shell` environment
#' 
#' This function needs an installation of Nix. `with_nix()` has two effects
#' to run code in isolated and reproducible environments.
#' 1. Evaluate a function in R or a shell command via the `nix-shell`
#'   environment (Nix expression for custom software libraries; involving pinned
#'   versions of R and R packages via Nixpkgs)
#' 2. If no error, return the result object of `expr` in `with_nix()` into the
#'   current R session.
#'
#'
#' 
#' `with_nix()` gives you the power of evaluating a main function `expr` 
#' and its function call stack that are defined in the current R session
#' in an encapsulated nix-R session defined by Nix expression (`default.nix`),
#' which is located in at a distinct project path (`project_path`).
#' 
#' `with_nix()` is very convenient because it gives direct code feedback in 
#' read-eval-print-loop style, which gives a direct interface to the very 
#' reproducible infrastructure-as-code approach offered by Nix and Nixpkgs. You
#' don't need extra efforts such as setting up DevOps tooling like Docker and
#' domain specific tools like {renv} to control complex software environments in
#' R and any other language. It is for example useful for the following
#' purposes.
#' 
#' 1. test compatibility of custom R code and software/package dependencies in
#'   development and production environments
#' 2. directly stream outputs (returned objects), messages and errors from any
#'   command line tool offered in Nixpkgs into an R session.
#' 3. Test if evolving R packages change their behavior for given unchanged
#'   R code, and whether they give identical results or not.
#' 
#' #' `with_nix()` can evaluate both R code from a nix-R session within
#' another nix-R session, and also from a host R session (i.e., on macOS or
#' Linux) within a specific nix-R session. This feature is useful for testing
#' the reproducibility and compatibility of given code across different software
#' environments. If testing of different sets of environments is necessary, you
#' can easily do so by providing Nix expressions in custom `.nix` or
#' `default.nix` files in different subfolders of the project.
#' 
#' To do its job, `with_nix()` heavily relies on patterns that manipulate
#' language expressions (aka computing on the language) offered in base R as
#' well as the {codetools} package by Luke Tierney.
#' 
#' Some of the key steps that are done behind the scene:
#' 1. recursively find, classify, and export global objects (globals) in the 
#' call stack of `expr` as well as propagate R package environments found.
#' 2. Serialize (save to disk) and deserialize (read from disk) dependent
#'  data structures as `.Rds` with necessary function arguments provided,
#'  any relevant globals in the call stack, packages, and `expr` outputs 
#'  returned in a temporary directory.
#' 3. Use pure `nix-shell` environments to execute a R code script 
#'   reconstructed catching expressions with quoting; it is launched by commands
#'  like this via `{sys}` by Jeroen Ooms:
#'  `nix-shell --pure --run "Rscript --vanilla"`.
#'
#' @param expr Single R function or call, or character vector of length one with
#' shell command and possibly options (flags) of the command to be invoked.
#' For `program = R`, you can both use a named or an anonymous function. 
#' The function provided in `expr` should not evaluate when you pass arguments,
#' hence you need to wrap your function call like
#' `function() your_fun(arg_a = "a", arg_b = "b")`, to avoid evaluation and make
#' sure `expr` is a function (see details and examples).
#' @param program String stating where to evaluate the expression. Either `"R"`,
#' the default, or `"shell"`. `where = "R"` will evaluate the expression via
#' `RScript` and `where = "shell"` will run the system command in `nix-shell`.
#' @param exec_mode Either `"blocking"` (default) or `"non-blocking`. This
#' will either block the R session while `expr` is running in a `nix-shell`
#' environment, oor running it in the background ("non-blocking"). While
#' `program = R` will yield identical results for foreground and background
#' evaluation (R object), `program = "shell"` will return list of exit status,
#' standard output and standard error of the system command and as text in
#' blocking mode.
#' @param project_path Path to the folder where the `default.nix` file resides. 
#' The default is `"."`, which is the working directory in the current R
#' session. This approach also useful when you have different subfolders 
#' with separate software environments defined in different `default.nix` files.
#' If you prefer to run code in custom `.nix` files in the same directory
#' using `with_nix()`, you can use the `nix_file` argument to specify paths
#' to `.nix` files.
#' @param nix_file Path to `.nix` file that contains the expressions defining
#' the Nix software environment in which you want to run `expr`. See
#'  `project_path` argument as an alternative way to specify the environment.
#' @param message_type String how detailed output is. Currently, there is 
#' either `"simple"` (default) or `"verbose"`, which shows the script that runs
#' via `nix-shell`.
#' @importFrom codetools findGlobals checkUsage
#' @export
#' @return 
#' - if `program = "R"`, R object returned by function given in `expr`
#' when evaluated via the R environment in `nix-shell` defined by Nix 
#' expression.
#' - if `program = "shell"`, list with the following elements:
#'     - `status`: exit code
#'     - `stdout`: character vector with standard output
#'     - `stderr`: character vector with standard error
#' of `expr` command sent to a command line interface provided by a Nix package.
#' @examples
#' \dontrun{
#' # create an isolated, runtime-pure R setup via Nix
#' project_path <- "./sub_shell"
#' rix_init(
#'   project_path = project_path,
#'   rprofile_action = "create_missing"
#' )
#' # generate nix environment in `default.nix`
#' rix(
#'   r_ver = "4.2.0",
#'   project_path = project_path
#' )
#' # evaluate function in Nix-R environment via `nix-shell` and `Rscript`,
#' # stream messages, and bring output back to current R session
#' out <- with_nix(
#'   expr = function(mtcars) nrow(mtcars),
#'   program = "R", exec_mode = "non-blocking", project_path = project_path,
#'   message_type = "simple"
#' )
#' 
#' # There no limit in the complexity of function call stacks that `with_nix()`
#' # can possibly handle; however, `expr` should not evaluate and 
#' # needs to be a function for `program = "R"`. If you want to pass the
#' # a function with arguments, you can do like this
#' get_sample <- function(seed, n) {
#'   set.seed(seed)
#'   out <- sample(seq(1, 10), n)
#'   return(out)
#' }
#' 
#' out <- with_nix(
#'   expr = get_sample(seed = 1234, n = 5),
#'   program = "R", exec_mode = "non-blocking",
#'   project_path = ".",
#'   message_type = "simple"
#' )
#' 
#' #' ## You can also use packages, which will be exported to the nix-R session
#' ## running through `nix-shell` environment
#' R 4.2.2
#' }
with_nix <- function(expr,
                     program = c("R", "shell"),
                     exec_mode = c("blocking", "non-blocking"),
                     project_path = ".",
                     nix_file = NULL,
                     message_type = c("simple", "verbose")) {
  if (is.null(nix_file)) {
    nix_file <- file.path(project_path, "default.nix")
  }
  stopifnot(
    "`project_path` must be character of length 1." =
      is.character(project_path) && length(project_path) == 1L,
    "`project_path` has no `default.nix` file. Use one that contains `default.nix`" =
      file.exists(nix_file),
    "`message_type` must be character." = is.character(message_type),
    "`expr` needs to be a call or function for `program = R`, and character of length 1 for `program = shell`" =
      is.function(expr) || is.call(expr) || (is.character(expr) && length(expr) == 1L)
  )
  
  # ad-hoc solution for RStudio's limitation that R sessions cannot yet inherit
  # proper `PATH` from custom `.Rprofile` on macOS (2023-01-17)
  # adjust `PATH` to include `/nix/var/nix/profiles/default/bin`
  if (isTRUE(is_rstudio_session()) && isFALSE(is_nix_rsession())) {
    set_nix_path()
  }
  
  has_nix_shell <- nix_shell_available() # TRUE if yes, FALSE if no
  stopifnot("`nix-shell` not available. To install, we suggest you follow https://zero-to-nix.com/start/install ." =
    isTRUE(has_nix_shell))
  
  if (isFALSE(has_nix_shell)) {
    stop(
      paste0("`nix-shell` is needed but is not available in your current ",
        "shell environment.\n",
        "* If you are in an R session of your host operating system, you
        either\n1a) need to install Nix first, or if you have already done so ",
        "\n",
        "1b) make sure that the location of the nix store is in the `PATH`
        variable of this R session (mostly necessary in RStudio).\n",
        "* If you ran `with_nix()` from R launched in a `nix-shell`, you need
        to make sure that `pkgs.nix` is in the `buildInput` for ",
        "`pkgs.mkShell`.\nIf you used `rix::rix()` to generate your main nix
        configuration of this session, just regenerate it with the additonal
        argument `system_pkgs = 'nix'."),
      call. = FALSE
    )
  }
  
  program <- match.arg(program)
  exec_mode <- match.arg(exec_mode)
  message_type <- match.arg(message_type)
  
  if (program == "R") {
  
    # get the function arguments as a pairlist;
    # save formal arguments of pairlist via `tag = value`; e.g., if we have a
    # `expr = function(p = p_root) dir(path = p)`, the input object
    # to be serialized will be serialized under `"p.Rds"`  in a tmp dir, and
    # will contain object `p_root`, which is defined in the global environment
    # and bound to `"."` (project root)
    args <- as.list(formals(expr))
    
    cat("\n### Prepare to exchange arguments and globals for `expr`",
      "between the host and Nix R sessions ###\n")
    
    # 1) save all function args onto a temporary folder each with
    # `<tag.Rds>` and `value` as serialized objects from RAM ---------------------
    temp_dir <- tempdir()
    serialize_args(args, temp_dir)
    
    # cast list of symbols/names and calls to list of strings; this is to prepare
    # deparsed version (string) of deserializing arguments from disk;
    # elements of args for now should be of type "symbol" or "language"
    args_vec <- vapply(args, deparse, FUN.VALUE = character(1L))
    
    # todo in `rnix_deparsed`:
    # => locate all global variables used by function
    # https://github.com/cran/codetools/blob/master/R/codetools.R
    # http://adv-r.had.co.nz/Expressions.html#ast-funs
    
    # code inspection: generates messages with potential problems
    check_expr(expr)
    
    globals_expr <- recurse_find_check_globals(expr, args_vec)
    
    # wrapper around `serialize_lobjs()`
    globals <- serialize_globals(globals_expr, temp_dir)
    
    # extract additional packages to export
    pkgs <- serialize_pkgs(globals_expr, temp_dir)
    
    # 2) deserialize formal arguments of `expr` in nix session
    # and necessary global objects ---------------------------------------------
    # 3) serialize resulting output from evaluating function given as `expr`
    
    # main code to be run in nix R session
    rnix_file <- file.path(temp_dir, "with_nix_r.R")
    
    rnix_quoted <- quote_rnix(
      expr, program, message_type, args_vec, globals, pkgs, temp_dir, rnix_file
    )
    rnix_deparsed <- deparse_chr1(expr = rnix_quoted, collapse = "\n")
    
    # 4): for 2) and 3) write script to disk, to run later via `Rscript` from
    # `nix-shell` 
    # environment
    r_version_file <- file.path(temp_dir, "nix-r-version.txt")
    writeLines(text = rnix_deparsed, file(rnix_file))
    
    # 3) run expression in nix session, based on temporary script
    cat(paste0("==> Running deparsed expression via `nix-shell`", " in ",
      exec_mode, " mode:\n\n"#,
      # paste0(rnix_deparsed, collapse = " ")
    ))
    
    # command to run deparsed R expression via nix-shell
    cmd_rnix_deparsed <- c(
      file.path(project_path, "default.nix"),
      "--pure", # required for to have nix glibc
      "--run",
      sprintf(
        "Rscript --vanilla '%s'",
        rnix_file
      )
    )
    
    proc <- switch(exec_mode,
      "blocking" = sys::exec_internal(cmd = "nix-shell", cmd_rnix_deparsed),
      "non-blocking" = sys::exec_background(
        cmd = "nix-shell", cmd_rnix_deparsed),
      stop('invalid `exec_mode`. Either use "blocking" or "non-blocking"')
    )
    if (exec_mode == "non-blocking") {
      poll_sys_proc_nonblocking(cmd = cmd_rnix_deparsed, proc, what = "expr")
    } else if (exec_mode == "blocking") {
      poll_sys_proc_blocking(cmd = cmd_rnix_deparsed, proc, what = "expr")
    }
  } else if (program == "shell") { # end of `if (program == "R")`
    shell_cmd <- c(
      file.path(project_path, "default.nix"),
      "--pure",
      "--run",
      expr
    )
    proc <- switch(exec_mode,
      "blocking" = sys::exec_internal(cmd = "nix-shell", shell_cmd),
      "non-blocking" = sys::exec_background(
        cmd = "nix-shell", shell_cmd),
      stop('invalid `exec_mode`. Either use "blocking" or "non-blocking"')
    )
  }
  
  # 5) deserialize final output of `expr` evaluated in nix-shell
  # into host R session
  if (program == "R") {
    out <- readRDS(file = file.path(temp_dir, "_out.Rds"))
    on.exit(close(file(rnix_file)))
  } else if (program == "shell") {
    if (exec_mode == "non-blocking") {
      status <- poll_sys_proc_nonblocking(
        cmd = shell_cmd, proc, what = "expr"
      )
      out <- status
    } else if (exec_mode == "blocking") {
      poll_sys_proc_blocking(cmd = shell_cmd, proc, what = "expr")
      out <- proc
      out$stdout <- sys::as_text(out$stdout)
      out$stderr <- sys::as_text(out$stderr)
    }
  }

  cat("\n### Finished code evaluation in `nix-shell` ###\n")
  
  # return output from evaluated function
  cat("\n* Evaluating `expr` in `nix-shell` returns:\n")
  if (program == "R") {
    print(out)
  } else if (program == "shell") {
    print(out$stdout)
  }
  
  unlink(file.path(temp_dir, "_out.Rds"), force = TRUE)
  
  cat("")
  return(out)
}


#' serialize language objects
#' @noRd
serialize_lobjs <- function(lobjs, temp_dir) {
  invisible({
    for (i in seq_along(lobjs)) {
      if (!any(nzchar(deparse(lobjs[[i]])))) {
        # for unnamed arguments like `expr = function(x) print(x)`
        # x would be an empty symbol, see also ; i.e. arguments without 
        # default expressions; i.e. tagged arguments with no value
        # https://stackoverflow.com/questions/3892580/create-missing-objects-aka-empty-symbols-empty-objects-needed-for-f
        lobjs[[i]] <- as.symbol(names(lobjs)[i])
      }
      saveRDS(
        object = lobjs[[i]],
        file = file.path(temp_dir, paste0(names(lobjs)[i], ".Rds"))
      )
    }
  })
}

serialize_args <- function(args, temp_dir) {
  invisible({
    for (i in seq_along(args)) {
      if (!nzchar(deparse(args[[i]]))) {
        # for unnamed arguments like `expr = function(x) print(x)`
        # x would be an empty symbol, see also ; i.e. arguments without 
        # default expressions; i.e., tagged arguments with no value
        # https://stackoverflow.com/questions/3892580/create-missing-objects-aka-empty-symbols-empty-objects-needed-for-f
        args[[i]] <- as.symbol(names(args)[i])
      }
      args[[i]] <- get(as.character(args[[i]]))
      saveRDS(
        object = args[[i]],
        file = file.path(temp_dir, paste0(names(args)[i], ".Rds"))
      )
    }
  })
}


#' @noRd
check_expr <- function(expr) {
    cat("* checking code in `expr` for potential problems:\n",
      "`codetools::checkUsage(fun = expr)`\n")
    codetools::checkUsage(fun = expr)
    cat("\n")
  }


#' @noRd
# to determine which extra packages to load in Nix R prior evaluating `expr`
get_expr_extra_pkgs <- function(globals_expr) {
  envs_check <- lapply(globals_expr, where)
  names_envs_check <- vapply(envs_check, environmentName, character(1L))
  
  default_pkgnames <- paste0("package:", getOption("defaultPackages"))
  pkgenvs_attached <- setdiff(
     grep("^package:", names_envs_check, value = TRUE), 
    c(default_pkgnames, "base")
  )
  if (!length(pkgenvs_attached) == 0L) {
    pkgs_to_attach <- gsub("^package:", "", pkgenvs_attached)
    return(pkgs_to_attach)
  } else {
    return(NULL)
  }
}


#' @noRd
is_empty <- function(x) identical(x, emptyenv())


#' @noRd
where <- function(name, env = parent.frame()) {
  while(!is_empty(env)) {
    if (exists(name, envir = env, inherits = FALSE)) {
      return(env)
    }
    # inspect parent
    env <- parent.env(env)
  }
}

#' Finds and checks global functions and variables recursively for closure
#' `expr`
#' @noRd
recurse_find_check_globals <- function(expr, args_vec) {
    
    cat("* checking code in `expr` for potential problems:\n")
    codetools::checkUsage(fun = expr)
    cat("\n")
    
    globals_expr <- codetools::findGlobals(fun = expr)
    globals_lst <- classify_globals(globals_expr, args_vec)
    
    round_i <- 1L
      
    repeat {
      
      get_globals_exprs <- function(globals_lst) {
        globals_exprs <- names(unlist(Filter(function(x) !is.null(x), 
          unname(globals_lst[c("globalenv_fun", "env_fun")]))))
        return(globals_exprs)
      }
      
      if (round_i == 1L) {
        # first round
        globals_exprs <- get_globals_exprs(globals_lst)
      } else {
        # successive rounds
        globals_exprs <- unlist(lapply(globals_lst, get_globals_exprs))
      }
      
      cat("* checking code in `globals_exprs` for potential problems:\n")
      lapply(
        globals_exprs,
        codetools::checkUsage
      )
      cat("\n")
    
      globals_new <- lapply(
        globals_exprs,
        function(x) codetools::findGlobals(fun = x)
      )
      
      globals_lst_new <- lapply(
        globals_new,
        function(x) classify_globals(globals_expr = x, args_vec)
      )
      
      if (round_i == 1L) {
        result_list <- c(list(globals_lst), globals_lst_new)
      } else {
        result_list <- c(result_list, globals_lst_new)
      }
      
      # prepare current globals to find new globals one recursion level deeper
      # in the call stack in the next repeat
      globals_lst <- globals_lst_new
      
      globals_lst <- lapply(globals_lst, function(x) lapply(x, unlist))
      
      # packages need to be excluded for getting more globals
      globals_lst <- lapply(
        globals_lst,
        function(x) {
          x[c("globalenv_fun", "globalenv_other", "env_other", "env_fun")]
        }
      )
      
      globals_null <- all(is.null(unlist(globals_lst)))
      # TRUE if no more candidate global values
      all_non_pkgs_null <- all(globals_null)
      
      round_i <- round_i + 1L
      
      if (is.null(globals_lst) || all_non_pkgs_null) break
    }
  
    result_list <- Filter(function(x) !is.null(x), result_list)
    result_list <- lapply(
      result_list, 
      function(x) Filter(function(x) !is.null(x), x)
    )
    
    pkgs <- unlist(lapply(result_list, "[", "pkgs"))
    
    unlist_unname <- function(x) {
      unlist(
        lapply(x,  function(x) unlist(unname(x)))
      )
    }
    
    globalenv_fun <- lapply(result_list, "[", "globalenv_fun")
    globalenv_fun <- unlist_unname(globalenv_fun)
    
    globalenv_other <- lapply(result_list, "[", "globalenv_other")
    globalenv_other <- unlist_unname(globalenv_other)
    
    env_other <- lapply(result_list, "[", "env_other")
    env_other <- unlist_unname(env_other)
    
    env_fun = lapply(result_list, "[", "env_fun")
    env_fun <- unlist_unname(env_fun)
    
    exports <- list(
      pkgs = pkgs,
      globalenv_fun = globalenv_fun,
      globalenv_other = globalenv_other,
      env_other = env_other,
      env_fun = env_fun
    )
    
    return(exports)
}

#' @noRd
classify_globals <- function(globals_expr, args_vec) {
  envs_check <- lapply(globals_expr, where)
  names(envs_check) <- globals_expr
  
  vec_envs_check <- vapply(envs_check, environmentName, character(1L))
  # directly remove formals
  vec_envs_check <- vec_envs_check[!names(vec_envs_check) %in% args_vec]
  if (length(vec_envs_check) == 0L) {
    vec_envs_check <- NULL
  }
  
  if (!is.null(vec_envs_check)) {
    globs_pkg <- grep("^package:", vec_envs_check, value = TRUE)
    if (length(globs_pkg) == 0L) {
      globs_pkg <- NULL
    }
    # globs base can be ignored
    globs_base <- grep("^base$", vec_envs_check, value = TRUE)
    globs_globalenv <- grep("^R_GlobalEnv$", vec_envs_check, value = TRUE)
    globs_globalenv <- Filter(nzchar, globs_globalenv)
    # empty globs; can be ignored for now
    globs_empty <- Filter(function(x) !nzchar(x), vec_envs_check)
    if (length(globs_empty) == 0L) {
      globs_empty <- NULL
    }
    globs_other <- vec_envs_check[!names(vec_envs_check) %in% 
      names(c(globs_pkg, globs_globalenv, globs_empty, globs_base))]
    if (length(globs_other) == 0L) {
      globs_other <- NULL
    }
  }
  
  is_globalenv_funs <- vapply(
    names(globs_globalenv), function(x) is.function(get(x)),
    FUN.VALUE = logical(1L)
  )
  
  is_otherenv_funs <- vapply(
    names(globs_other), function(x) is.function(get(x)),
    FUN.VALUE = logical(1L)
  )
  
  globs_globalenv_fun <- globs_globalenv[is_globalenv_funs]
  if (length(globs_globalenv_fun) == 0L) {
    globs_globalenv_fun <- NULL
  }
  globs_globalenv_other <- globs_globalenv[!is_globalenv_funs]
  if (length(globs_globalenv_other) == 0L) {
    globs_globalenv_other <- NULL
  }
  
  globs_otherenv_fun <- globs_other[is_otherenv_funs]
  if (length(globs_otherenv_fun) == 0L) {
    globs_otherenv_fun <- NULL
  }
  globs_otherenv_other <- globs_other[!is_otherenv_funs]
  if (length(globs_otherenv_other) == 0L) {
    globs_otherenv_other <- NULL
  }
  
  default_pkgnames <- paste0("package:", getOption("defaultPackages"))
  pkgenvs_attached <- setdiff(globs_pkg, c(default_pkgnames, "base"))

  if (!length(pkgenvs_attached) == 0L) {
    pkgs_to_attach <- gsub("^package:", "", pkgenvs_attached)
  } else {
    pkgs_to_attach <- NULL
  }
  
  globs_classified <- list(
    globalenv_fun = globs_globalenv_fun,
    globalenv_other = globs_globalenv_other,
    env_other = globs_otherenv_other,
    env_fun = globs_otherenv_fun,
    pkgs = pkgs_to_attach
  )
  globs_null <- all(vapply(globs_classified, is.null, logical(1L)))
  if (globs_null) globs_classified <- NULL
  
  return(globs_classified)
}


# wrapper to serialize expressions of all global objects found
#' @noRd
serialize_globals <- function(globals_expr, temp_dir) {
  funs <- globals_expr$globalenv_fun
  if (!is.null(funs)) {
    cat("=> Saving global functions to disk:", paste(names(funs)), "\n")
    globalenv_funs <- lapply(
      names(funs),
      function(x) get(x = x, envir = .GlobalEnv)
    )
    names(globalenv_funs) <- names(globals_expr$globalenv_fun)
    serialize_lobjs(lobjs = globalenv_funs, temp_dir)
  }
  others <- globals_expr$globalenv_other
  if (!is.null(others)) {
    cat("=> Saving non-function object(s), e.g. other environments:",
      paste(names(others)), "\n"
    )
    globalenv_others <- lapply(
      names(others),
      function(x) get(x = x, envir = .GlobalEnv)
    )
    names(globalenv_others) <- names(globals_expr$globalenv_other)
    serialize_lobjs(lobjs = globalenv_others, temp_dir)
  }
  env_funs <- globals_expr$env_fun
  if (!is.null(env_funs)) {
    cat("=> Serializing function(s) from other environment(s):",
      paste(names(env_funs)), "\n")
    env_funs <- lapply(
      names(env_funs),
      function(x) get(x = x)
    )
    names(env_funs) <- names(globals_expr$env_fun)
    serialize_lobjs(lobjs = env_funs, temp_dir)
  }
  env_others <- globals_expr$env_other
  if (!is.null(env_others)) {
    cat("=> Serializing non-function object(s) from custom environment(s)::",
      paste(names(env_others)), "\n"
    )
    env_others <- lapply(
      names(env_others),
      function(x) get(x = x)
    )
    names(env_others) <- names(globals_expr$env_other)
    serialize_lobjs(lobjs = env_others, temp_dir)
  }
  
  return(c(funs, others, env_funs, env_others))
}


#' @noRd
serialize_pkgs <- function(globals_expr, temp_dir) {
  pkgs <- globals_expr$pkgs
  if (!is.null(pkgs)) {
    cat("=> Serializing package(s) required to run `expr`:\n",
      paste(pkgs), "\n"
    )
  }
  saveRDS(
    object = pkgs,
    file = file.path(temp_dir, "_pkgs.Rds")
  )
  return(pkgs)
}

# build deparsed script via language objects;
# reads like R code, and avoids code injection
quote_rnix <- function(expr,
                       program,
                       message_type,
                       args_vec,
                       globals,
                       pkgs,
                       temp_dir,
                       rnix_file) {
  expr_quoted <- bquote( {
    cat("### Start evaluating `expr` in `nix-shell` ###")
    cat("\n* wrote R script evaluated via `Rscript` in `nix-shell`:",
      .(rnix_file))
    temp_dir <- .(temp_dir)
    cat("\n", Sys.getenv("NIX_PATH"))
    # fix library paths for nix R on macOS and linux; avoid permission issue
    current_paths <- .libPaths()
    userlib_paths <- Sys.getenv("R_LIBS_USER")
    user_dir <- grep(paste(userlib_paths, collapse = "|"), current_paths)
    new_paths <- current_paths[-user_dir]
    .libPaths(new_paths)
    r_version_num <- paste0(R.version$major, ".", R.version$minor)
    cat("\n* using Nix with R version", r_version_num, "\n\n")
    # assign `args_vec` as in c(...) form.
    args_vec <- .(with_assign_vecnames_call(vec = args_vec))
    # deserialize arguments from disk
    for (i in seq_along(args_vec)) {
      nm <- args_vec[i]
      obj <- args_vec[i]
      assign(
        x = nm,
        value = readRDS(file = file.path(temp_dir, paste0(obj, ".Rds")))
      )
      cat(
        paste0("  => reading file ", "'", obj, ".Rds", "'",
          " for argument named `", obj, "`\n")
      )
    }

    globals <- .(with_assign_vecnames_call(vec = globals))
    for (i in seq_along(globals)) {
      nm <- globals[i]
      obj <- globals[i]
      assign(
        x = nm,
        value = readRDS(file = file.path(temp_dir, paste0(obj, ".Rds")))
      )
      cat(
        paste0("  => reading file ", "'", obj, ".Rds", "'",
          " for global object named `", obj, "`\n")
      )
    }

    # for now name of character vector containing packages is hard-coded
    # pkgs <- .(with_assign_vecnames_call(vec = pkgs))
    # pkgs <- .(pkgs)
    pkgs <- .(with_assign_vec_call(vec = pkgs))
    lapply(pkgs, library, character.only = TRUE)

    # execute function call in `expr` with list of correct args
    lst <- as.list(args_vec)
    names(lst) <- args_vec
    lst <- lapply(lst, as.name)
    rnix_out <- do.call(.(expr), lst)
    cat("\n* called `expr` with args", args_vec, ":\n")
    message_type <- .(message_type)
    if (message_type == "verbose") {
    # cat("\n", deparse(.(expr))) # not nicely formatted, use print
      # print(.(expr))
    }
    cat("\n* The type of the output object returned by `expr` is",
      typeof(rnix_out))
    saveRDS(object = rnix_out, file = file.path(temp_dir, "_out.Rds"))
    cat("\n* Saved output to", file.path(temp_dir, "_out.Rds"))
    cat("\n\n* the following objects are in the global environment:\n")
    cat(ls())
    cat("\n")
    cat("\n* `sessionInfo()` output:\n")
    try(cat(capture.output(sessionInfo()), sep = "\n"))
  } ) # end of `bquote()`

  return(expr_quoted)
}

# https://github.com/cran/codetools/blob/master/R/codetools.R
# finding global variables

# reconstruct argument vector (character) in Nix R;
# build call to generate `args_vec`
#' @noRd
with_assign_vecnames_call <- function(vec) {
  cl <- call("c")
  for (i in seq_along(vec)) {
    cl[[i + 1L]] <- names(vec[i])
  }
  return(cl)
}

#' @noRd
with_assign_vec_call <- function(vec) {
  cl <- call("c")
  for (i in seq_along(vec)) {
    cl[[i + 1L]] <- vec[i]
  }
  return(cl)
}

# this is what `deparse1()` does, however, it is only since 4.0.0
#' @noRd
deparse_chr1 <- function(expr, width.cutoff = 500L, collapse = " ", ...) {
  paste(deparse(expr, width.cutoff, ...), collapse = collapse)
}

#' @noRd
with_expr_deparse <- function(expr) {
  sprintf(
    'run_expr <- %s\n',
    deparse_chr1(expr = expr, collapse = "\n")
  )
}

#' @noRd
nix_shell_available <- function() {
  # for local tests via `devtools::test()` in RStudio
  old_path <- Sys.getenv("PATH")
  nix_path <- "/nix/var/nix/profiles/default/bin"
  has_nix_path <- any(grepl(nix_path, old_path))
  if (isFALSE(has_nix_path)) {
    Sys.setenv(PATH = paste(old_path, nix_path, sep = ":"))
  }
  which_nix_shell <- Sys.which("nix-shell")
  if (nzchar(which_nix_shell)) {
    return(TRUE)
  } else {
    return(FALSE)
  }
}

#' @noRd
create_shell_nix <- function(path = file.path("inst", "extdata", 
                              "with_nix", "default.nix")) {
  if (!dir.exists(dirname(path))) {
    dir.create(dirname(path), recursive = TRUE)
  }

  rix(
    r_ver = "latest",
    r_pkgs = NULL,
    system_pkgs = NULL,
    git_pkgs = NULL,
    ide = "other",
    project_path = dirname(path),
    overwrite = TRUE,
    shell_hook = NULL
  )
}
```

```{r, tests-with_nix}
testthat::test_that("Test 2 for with_nix() if Nix is installed", {
  
  skip_if_not(nix_shell_available())
  
  path_subshell <- tempdir()
  
  rix_init(
    project_path = path_subshell,
    rprofile_action = "overwrite",
    message_type = "simple"
  )
  
  rix(
    r_ver = "4.2.0",
    overwrite = TRUE,
    project_path = path_subshell
  )
  
  df <- data.frame(a = 1:3, b = 4:6)
  
  out_subshell <- with_nix(
    expr = function() {
      as.vector(x = data.frame(a = 1:3, b = 4:6), mode = "list")
    },
    program = "R",
    exec_mode = "non-blocking",
    project_path = path_subshell,
    message_type = "verbose"
  )
  
  testthat::expect_false(
    inherits(out_subshell, "data.frame")
  )
})


testthat::test_that("Testing with_nix() if Nix is installed", {

  skip_if_not(nix_shell_available())

  path_subshell <- tempdir()

  rix_init(
    project_path = path_subshell,
    rprofile_action = "overwrite",
    message_type = "simple"
  )

  rix(
    r_ver = "3.5.3",
    overwrite = TRUE,
    project_path = path_subshell
  )

  out_subshell <- with_nix(
    expr = function(){
      set.seed(1234)
      a <- sample(seq(1, 10), 5)
      set.seed(NULL)
      return(a)
    },
    program = "R",
    exec_mode = "non-blocking",
    project_path = path_subshell,
    message_type = "simple"
  )

  # On a recent version of R, set.seed(1234);sample(seq(1,10), 5)
  # returns c(10, 6, 5, 4, 1)
  # but not on versions prior to 3.6
  testthat::expect_true(
    all(c(2, 6, 5, 8, 9) == out_subshell)
  )


})

```
